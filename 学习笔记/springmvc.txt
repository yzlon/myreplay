web.xml配置，默认的是寻找[servlet-name]-servlet.xml配置
可以用：
	<servlet>
		<servlet-name>springmvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:mvc.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	
controller的配置方式
第一种：URL对应Bean，xml配置如下(001springmvc_hello就是这样的配置)：
	<!-- 配置handlerMapper -->
	<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" />
	<bean name="/hello.do" class="com.yzl.controller.HelloController" />
	HelloController实现接口Controller
	以上配置，等用/hello.do访问的时候就会找到/hello.do的Bean，此类方式适合小型的应用系统。
	
第二种: 为URL分配Bean，使用一个统一的配置集合，对各个URL对应的Contoller做关系映射(003springmvc_url2controller)
    mvc.xml配置：
	<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="mappings">
			<props>
				<!-- key对应着url的请求名,可以用通配符 value对应处理器的id -->
				<prop key="/hello.do">helloController</prop>
			</props>
		</property>
	</bean>
	<bean id="helloController" class="com.yzl.controller.HelloController" />
	HelloController 要实现Controller接口
	这种方式也是最常用的方式

第三种： URL匹配Bean
    mvc.xml配置：
	必须遵命名的规范
	<!-- hello*.do的请求将交给helloController处理 -->
	<bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/>
	<bean id="helloController" class="com.yzl.controller.HelloController" />
	HelloController实现接口Controller

第四种：注解的方式 002springmvc_annotation
    mvc.xml配置：
	必须在xml开启spring注解
	<!-- 扫描该包下的注解 -->
	<context:component-scan base-package="com.yzl.controller" />
	HelloController类要加上注解@Controller 和 @RequestMapping("/hello")(此注解可以放到类前面或者方法前面)
	
004springmvc_jump_way1
1、跳转的方式1.设置ModelAndView（前面的例子都是）
    页面:视图解析器的前缀+view name+视图解析器的后缀
	根据ModelAndView
2、通过ServletAPI对象来实现,不需要视图配置
	2.1通过HttpServletResponse来进行输出
	   resp.getWriter.println("xxxx");
	2.2 通过HttpServletResponse来进行重定向
	    resp.sendRedirect("index.jsp");
	2.3HttpServletRequest请求转发重定向
	   req.getRequestDispatcher("index.jsp").req(req,resp);
3、通过Springmvc实现转发和重定向-没有视图解析器
   3.1 转发的实现一
       return "index.jsp";
   3.2 转发的实现二
       return "forword:index.jsp"
   3.3 重定向
       return "redirect:index.jsp";
4、通过Springmvc实现转发和重定向-有视图解析器
   4.1转发的方式
   4.2重定向
   	重定向不会走视图解析器的。只是普通的重定向。其实重定向已经和视图解析器没有关系了。
      注意：重定向redirect:index.jsp不需要视图解析器
      
 数据的处理

 1、提交数据的处理 005springmvc_data
 	springmvc的Controller是单例的
        参数的方式传递：
        	域名称和方法的参数名称一致即可
        		请求：http://localhost:8080/005springmvc_data/hello.do?name=zhangsan
        		函数：hello(String name)
			不一致可以用
				请求：http://localhost:8080/005springmvc_data/hello.do?uname=zhangsan
				函数：hello(@RequestParam("uname")String name) uname是域名称
 			如果提交的是一个对象,域只把对象的属性一一列出就可：name=zhangsan&age=23
				请求：http://localhost:8080/005springmvc_data/hello.do?name=zhangsan&age=23
				函数：hello(User user)
				User必须有setter和getter
				
2、将数据显示到UI层
   2.1 通过ModelAndView-需要视图解析器（前面的例子）
   2.2 通过ModelMap-不需要视图解析器
       ModelMap需要作为方法的形式参数传入
       public String hello(String name,ModelMap model){}
   ModelAndView和ModelMap的区别
		相同点：都可以将数据封装显示到表示层的页面中
		不同点：
			ModelAndView可以指定跳转的视图(mv.setViewName("hello"))，而ModelMap不能
        	ModelAndView需要视图解析器，ModelMap不需要



乱码及Restful
1、乱码的解决(POST乱码的问题)-通过过滤器来解决：
		springmvc提供了CharactorEncodingFilter来解决乱码
   web.xml<filter-name>
   如果是get方式的乱码
   	修改tomcat的配置解决
   	自定义乱码解决的过滤器
2、Restful风格的Url
   优点：轻量级  安全 效率比较高
   http://xxxxxx/delete/123.do
   @RequestMapping("delete/{id}")
   http://xxxxx/234/234/234/delete.do
   @RequestMapping("{id1}/{id2}/{id3}/delete")
   public String hello(@PathVariable("id") int id){id=123}
 	    
 	
 	    
 	    
 	    
 	    
 	    
 	    
 	    
 	    
 	    
 	    
 	    